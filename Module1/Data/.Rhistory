"devtools")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
#Install TrainSel itself:
library(devtools)
install_github("TheRocinante-lab/TrainSel")
install.packages("prettydoc")
devtools::install_github("SFUStatgen/LDheatmap")
require("knitr")
opts_knit$set(root.dir = "~/Documents/Research/Workshops/IRRI-IIRR_2024/Module2")
rm(list=ls()) # remove the previous history
# Install
#install.packages("BGLR")
#install.packages("genetics")
# Installing snpStats package from Bioconuctor
#if (!requireNamespace("BiocManager", quietly = TRUE))
#install.packages("BiocManager")
#BiocManager::install("snpStats")
# Load the packages
library(BGLR)
library(genetics)
library(pheatmap)
#library(LDheatmap)
# Read the mice marker data
#mice.X<-read.csv(file="mice.X.csv", header = TRUE)
# Load the mice data
data(mice)
# Subset the mice data, first 20 markers
mice.20<- mice.X[, 1:20] # use the first 10 markers
# Visualize first 5 rows and columns
mice.20[1:5, 1:5] # Data is coded 0, 1 and 2
# Make genotypes
mice.20.G<- makeGenotypes(mice.20, convert=c(colnames(mice.20)), method=as.genotype.allele.count)
# Visualize first 5 rows and columns
mice.20.G[1:5, 1:5] # Data is coded 0, 1 and 2
# Now calculate the LD
LD.20<- LD(mice.20.G) # This will return the list
names (LD.20)
# Extract r2 ( Hill and Robertson (1968)
r2<-LD.20$`R^2`
# Copy upper part of matrix to lower for visualizations
lowerTriangle(r2) <- upperTriangle(r2)
# Convert Diagonal to 1
diag(r2)<-1
ld.map<-heatmap(r2)
ld.map
# Create a subset of SNPs to Visualize
mice.map1<-mice.map[1:10, ]
mice.g<-mice.20[, colnames(mice.20)%in%mice.map1$snp_id]
mice.g<-mice.g[1:50, ]
# Make genotypes
mice.g.ld<- makeGenotypes(mice.g, convert=c(colnames(mice.g)), method=as.genotype.allele.count)
# Visualize first 5 rows and columns
mice.20.G[1:5, 1:5] # Data is coded 0, 1 and 2
# Now calculate the LD
LD.mice.g<- LD(mice.g.ld) # This will return the list
# Extract r2 ( Hill and Robertson (1968)
r2<-LD.mice.g$`R^2`
# Copy upper part of matrix to lower for visualizations
lowerTriangle(r2) <- upperTriangle(r2)
# Convert Diagonal to 1
diag(r2)<-1
# Get the LD heatmap
source("LDheatmap.R")
LDheatmap(r2,genetic.distances=mice.map1$mbp, LDmeasure="r",
title="Pairwise LD in r^2", add.map=TRUE,
SNP.name=c("rs13475700_A", "rs6269442_G"),
color=heat.colors(20), name="myLDgrob",
add.key=TRUE)
View(LDheatmap)
# List all .R files in the directory
files <- list.files("./R", pattern = "\\.R$", full.names = TRUE)
# Loop through each file and source it
for (file in files) {
source(file)
}
View(LDheatmap)
source("LDheatmap.R")
View(LDheatmap)
# Create a subset of SNPs to Visualize
mice.map1<-mice.map[1:10, ]
mice.g<-mice.20[, colnames(mice.20)%in%mice.map1$snp_id]
mice.g<-mice.g[1:50, ]
# Make genotypes
mice.g.ld<- makeGenotypes(mice.g, convert=c(colnames(mice.g)), method=as.genotype.allele.count)
# Visualize first 5 rows and columns
mice.20.G[1:5, 1:5] # Data is coded 0, 1 and 2
# Now calculate the LD
LD.mice.g<- LD(mice.g.ld) # This will return the list
# Extract r2 ( Hill and Robertson (1968)
r2<-LD.mice.g$`R^2`
# Copy upper part of matrix to lower for visualizations
lowerTriangle(r2) <- upperTriangle(r2)
# Convert Diagonal to 1
diag(r2)<-1
# Get the LD heatmap
source("LDheatmap.R")
LDheatmap(r2,genetic.distances=mice.map1$mbp, LDmeasure="r",
title="Pairwise LD in r^2", add.map=TRUE,
SNP.name=c("rs13475700_A", "rs6269442_G"),
color=heat.colors(20), name="myLDgrob",
add.key=TRUE)
View(LDheatmap)
library("optiSel")
install.packages("rgl", type = "source")
library("optiSel")
library(rgl)
library(rgl)
library("optiSel")
data(Cattle)
View(Cattle)
phen <- Cattle
data(map)
View(map)
dir     <- system.file("extdata", package="optiSel")
GTfiles <- file.path(dir, paste("Chr", unique(map$Chr), ".phased", sep=""))
GTfiles
Animal <- segInbreeding(GTfiles, map, minSNP=20, minL=1.0)
Animal
sKin <- segIBD(GTfiles, map, minSNP=20, minL=1.0)
View(sKin)
install.packages("ggplot2")
# Examples of R Exression
# Add
2+2
# Subtract
4-2
# Square
2^2
# Division
10/2
# Multiple
5*5
# Log
log(10)
# Exponential
exp(10)
# Create sample data
x <- seq(1, 10, by=1)  # x values from 1 to 10
x
y <- x^2  # y values are the squares of x
y
# Plot the data
plot(x, y,
main="Plot of y = x^2",  # Title of the plot
xlab="X-axis",            # Label for the x-axis
ylab="Y-axis",            # Label for the y-axis
col="blue",               # Color of the points
pch=19)
# Plot the data
plot(x, y,
main="Plot of y = x^2",  # Title of the plot
xlab="X axis vales",            # Label for the x-axis
ylab="Y-axis",            # Label for the y-axis
col="red",               # Color of the points
pch=10)
# Question: How many Arguments are in function
plot()?
# Can you figure positional matching
# RATIONAL OPERATORS (Returns TRUE or FALSE)
# Is 3 > 4
3>4
plot()?
# Question: How many Arguments are in function
?plot()
# Question: How many Arguments are in function
help(plot())
# Question: How many Arguments are in function
help("plot")
# RATIONAL OPERATORS (Returns TRUE or FALSE)
# Is 3 > 4
3>4
# Is 5 > 4
5>4
# Is 5==5
5==5
# Is 2 not equal to 3
2!=3
# LOGICAL OPERATORS
vector <- c(1, 2, 3, 4, 5) # Creating a simple vector
# Check which elements are greater than 2 and less than 5
result <- vector[vector > 2 & vector < 5]  # result will be c(3, 4)
result
# LOGICAL OPERATORS
vector <- c(1, 2, 3, 4, 5) # Creating a simple vector
result
# NUMERIC TYPE
num1 <- 5     # Integer
# NUMERIC TYPE
num1 <- 5     # Integer
num2 <- 3.14   # Decimal (floating-point)
num2
# INTEGER TYPE
int_num <- 10L # Integer type
int_num
# CHARACTER TYPE
char<- "Hello, R!"  # Character string
char
class(char)
class(int_num)
# LOGICAL
True_type <- TRUE
False_type <- FALSE
False_type
# COMPLEX
complex_num <- 3 + 2i  # 3 is the real part, and 2 is the imaginary part
complex_num
# Examples of numeric scalers
a <- 100
# Examples of numeric scalers
a <- 100
a
b <- 3 / 100
b
c <- (a + b) / b
c
# Examples of character scalers
d <- "ship"
d
e <- "cannon"
e
f <- "Do any modern armies still use cannons?"
f
# Example of Vector
X<-c(1,2,3,4,5, 6) # five components
X
# Check length
length(X)
# Creating a vector of 2s eight times
d<-rep(2, 8)
d
length(d)
class(d)
x[1] # Extract first element
x[c(1,2, 6)] # Extract first, second and 6 element in vector x (sub vector)
x[1:3] # Extracts elemnts from 1 to thrid position
x[-6] # Drops last element
x[-6] # Drops last element
x
sum(x) # sum function adds all elements
mean(x) # get mean of x
min(x) # get minimal value
max(x) # Get maximum value
# Creat a matrix
## 2.3.1 First approach
m2<-matrix(1:9, nrow = 3, ncol = 3) # Matrix with 3 rows and columns
m2 # Matrix filled by rows
m2<-matrix(1:9, nrow=3, ncol=3, byrow = TRUE)
# Assign names to rows and columns
dimnames(m2)<-list(c("X","Y","Z"), c("A","B","C"))
m2
m2<-matrix(1:9, nrow = 3, ncol = 3) # Matrix with 3 rows and columns
m2 # Matrix filled by rows
m2<-matrix(1:9, nrow=3, ncol=3, byrow = TRUE)
dimnames(m2)
# Assign names to rows and columns
dimnames(m2)<-list(c("X","Y","Z"), c("A","B","C"))
m2
# Access and chnage the row and column names
colnames(m2) # Get column names
row.names(m2)
colnames(m2)
# Change the namaes of columns
colnames(m2)<-c("A.1", "B.1", "C.1")
m2
# Change the namaes of columns
colnames(m2)<-c("A.1", "C.1")
# We can use cbind() and rbind() functions, column and row bind
x<-c(4,2,3,6) # create a vector of x
y<-c(8,5,6,9) # create a vector of y
m.col<-cbind(x,y) # now use cbind to bind two vectors column wise
m.col
m.row<-rbind(x,y) # now use cbind to bind two vectors row wise
m.row
### Extract the elements of matrices.
## Square bracket [] indexing method. Elements can be accessed as var[row, column].
# First create a new matrix
m2<-matrix(1:12, nrow=3, ncol=4, byrow = TRUE)
class(m2)
m2[1,] # Extracts first row
m2
m2[1,] # Extracts first row
m2[,4] # Extracts  4th column
m2[1,4] # Extracts first elemnt in row 1 and column 1
m2[c(1,3), c(1,2)]
## Modify the matrix
m2[1,1]<-10 # Chnages single element in first row and first column
m2
## Modify the matrix
m2[1,1]<-10 # Chnages single element in first row and first column
m2
m2[m2>11]<-20 # Chnage the elements in matrix greater than 12
m2
# Create a data.frame
Genotypes <- c("Genotyp1", "Genotype1", "Genotype2", "Genotype2")
Replication <- c("1","1","2","2")
Block<- c("Block1", "Block2", "Block1", "Block2")
Yield<-c(2500,3500,3200,4500)
mydata <- data.frame(Genotypes,Replication,Block,Yield)
View(mydata)
# Check the structure
str(mydata)
# Change the varaibales
mydata$Block<-as.factor(mydata$Block)
mydata$Replication
# Change the varaibales
mydata$Block<-as.factor(mydata$Block)
mydata$Replication<-as.factor(mydata$Replication)
# Check the structure again
str(mydata)
levels(mydata$Replication) # Determine the number of levels for replication.
# Check column names
names(mydata)
mydata$Yield
mydata[mydata$Yield>3500,] # Extract row that has yield greater than 3500
View(mydata)
mydata2<-subset(mydata,Block=="Block1") # select just Block1
mydata2
mydata2<-subset(mydata,Block=="Block1" & Replication=="1") # select just Block1
mydata2
# Creating a simple list
my_list <- list(name = "Waseem", age = 39, height = 5.5, is_student = FALSE)
my_list
my_list$name
# Mixed List: Creating a list with different types of elements
mixed_list <- list(vector = c(1, 2, 3),
matrix = matrix(1:4, nrow = 2),
char = "Hello",
logical = c(TRUE, FALSE))
mixed_list
# IF and Else Functions in R
# Example 1
x <- 10
y <- 12
if(x < y) {
print("x is less than 12!")
}
# Example 2
data("iris")
View(iris)
if(mean(iris$Sepal.Length)!=mean(iris$Petal.Length)){
print("It is true")
}
mean(iris$Sepal.Length)
mean(iris$Petal.Length)
# Example 1
x <- 10
y <- 12
if(x > y) {
print("x is greater than y")
} else {
print("y is greater than x")
}
if(x > y) {
print("x is greater than y")
} else {
print("y is greater than x")
}
# Example 2
if(mean(iris$Sepal.Length)<mean(iris$Petal.Length)) {
print("This is true and mean of sepal length is less than petal length")
} else {
print("This is false and mean of petal length is less than sepal length")
}
# Example 1
x <- 12
y <- 13
if(x > y) {
print("x is greater")
} else if(x < y) {
print("y is greater")
} else {
print("x and y are equal")
}
# Example 2
x <- 12
y <- 12
if(x > y) {
print("x is greater")
} else if(x < y) {
print("y is greater")
} else {
print("x and y are equal")
}
# Example of Multiple conditions
# First let us check means
mean(iris$Sepal.Length)
mean(iris$Petal.Length)
mean(iris$Sepal.Width)
mean(iris$Petal.Width)
# Test the multiple conditions using operators
if(mean(iris$Sepal.Length)>mean(iris$Petal.Length) &&
mean(iris$Sepal.Width)>mean(iris$Petal.Width) ) {
plot(iris$Sepal.Length, main="Sepal length",
ylab="Values")
} else {
plot(iris$Petal.Length, main="Petal length",
ylab="Values")
}
# Test the multiple conditions using operators
if(mean(iris$Sepal.Length)>mean(iris$Petal.Length) &&
mean(iris$Sepal.Width)>mean(iris$Petal.Width) ) {
plot(iris$Sepal.Length, main="Sepal length",
ylab="Values")
} else {
plot(iris$Petal.Length, main="Petal length",
ylab="Values")
}
# Test the multiple conditions using operators
if(mean(iris$Sepal.Length)>mean(iris$Petal.Length) &&
mean(iris$Sepal.Width)>mean(iris$Petal.Width) ) {
plot(iris$Sepal.Length, main="Sepal length",
ylab="Values")
} else {
plot(iris$Petal.Length, main="Petal length",
ylab="Values")
}
# First create a matrix
my.matrx <- matrix(c(1:10, 11:20, 21:30), nrow = 10, ncol = 3)
my.matrx
colnames(my.matrx)<-c("Length", "Breadth", "Width")
View(my.matrx)
#Get sum across rows by using apply function
sumrow<-apply(my.matrx, 2, mean)
sumrow
# Creating own function
sumrow<-apply(my.matrx, 1, function (x) sum(x)*2)
sumrow
# Creating function outside and then apply
# Creating a function to calculate Cofficient of variation
my.cofvar<- function(x){
(sd(x)/mean(x))*100
}
# Now apply it it dataframe or matrix
cv<-apply(my.matrx,1, my.cofvar)
cv
## lapply Function
# Create a list first
list.1<-list(Length=c(6,4,8,6.5),breadth=c(7,8,6,8),width=c(6.8,7.2,6.6,8))
list.1
# Get mean of all lists using lapply function
mean.all <- lapply(list.1,mean)
mean.all # Mean for all the lists
## sapply Function
# Create a vector first
vec<-c(1,2,3,4,5,6,7,8)
mean.vec <- sapply(vec,mean)
mean.vec
# Additional argument simplify
vec<-c(1,2,3,4,5,6,7,8)
mean.vec <- sapply(vec,mean, simplify = FALSE) # RETURNS REULTS AS LAPPLY
mean.vec
# tapply Function
# First creating a simple data frame
sample.data <- data.frame(Genotypes=c("Geno1","Geno2","Geno3","Geno4",
"Geno5","Geno6","Geno7"),
Yield=c(240, 220, 211, 230, 203, 241, 212),
Type=factor(c("LR","LR","LR","CV", "CV","CV","LR")))
View(sample.data)
# Now apply tapply function to get mean for various factor levels
mean<-tapply(sample.data$Yield, sample.data$Type, sum)
mean
#  For loop
# Example 1
for (i in 1:5) {
print(i^3)
}
# Example 2
x <- c(-8, 9, 11, 45)
for (i in x) {
y<-x/2
print(y)
}
# Example 3
# Histogram for iris data all columns
# Get iris data
data(iris)
View(iris)
# Histograms
par(mfrow = c(2, 2)) # Create 2 x 2 plotting matrix
for (i in 1:ncol(iris[,c(1:4)])){ # loop over columns
plot <- hist(iris[,i], main=paste("Trait", i))
plot
}
setwd("~/Documents/Research/Workshops/IRRI-IIRR_2024/Module1/Data")
#setwd("C:Documents/Research/Workshops/") # In windows, replace path
# Get a working directory
getwd()
dir.create("Test")
# Read from web directly
rice.pheno <- read.table("http://www.ricediversity.org/data/sets/44kgwas/RiceDiversity_44K_Phenotypes_34traits_PLINK.txt",
header = TRUE, stringsAsFactors = FALSE, sep = "\t")
View(rice.pheno)
library(dplyr)
View(iris)
# Function FILTER
iris1<-iris %>% filter(Species == "setosa", Species.abr == "sts")
iris$Species.abr<-abbreviate(iris$Species, minlength = 3)
# Function FILTER
iris1<-iris %>% filter(Species == "setosa", Species.abr == "sts")
View(iris1)
View(iris1)
# Function ARRANGE
iris1<- iris1 %>% arrange(Sepal.Length)
View(iris1)
###############################PIPE MULTIPLE TASKS#############################
# Pipe to perform multiple tasks
test<-iris %>%
filter(Species == "setosa")%>% # filter
mutate(SePAL.2=Sepal.Length/ 10)%>% # create new column
select(SePAL.2, Species) # and select the column
View(test)
